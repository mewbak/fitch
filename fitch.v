(* generated by Ott 0.25 from: fitch.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.

Require Export dyadicnat.
Require Export Structures.OrderedTypeEx.
Require Export FMapInterface.

Module Type PropInterpretation.
Parameter A : Type.
End PropInterpretation.

Module Fitch 
 (Import PI : PropInterpretation)
 (ST : SpecType) (SUOT : SpecUsualOrderedType ST)
 (DST : DyadicSpecType ST) (SUOTD : SpecUsualOrderedType DST)
 (Map : FMapInterface.S with Module E := SUOTD).

Definition p := A. (*r atomic proposition *)
Definition l := SUOT.t. (*r proof entry label *)
Definition eq_l: forall (x y : l), {x = y} + {x <> y} := SUOT.eq_dec.
Hint Resolve eq_l : ott_coq_equality.
Definition n := nat. (*r index variable (subscript) *)
Lemma eq_n: forall (x y : n), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_n : ott_coq_equality.

Inductive justification : Type :=  (*r derivation justification *)
 | justification_premise : justification
 | justification_lem : justification
 | justification_copy (l5:l)
 | justification_andi (l5:l) (l':l)
 | justification_ande1 (l5:l)
 | justification_ande2 (l5:l)
 | justification_ori1 (l5:l)
 | justification_ori2 (l5:l)
 | justification_impe (l5:l) (l':l)
 | justification_nege (l5:l) (l':l)
 | justification_conte (l5:l)
 | justification_negnegi (l5:l)
 | justification_negnege (l5:l)
 | justification_mt (l5:l) (l':l)
 | justification_impi (l5:l) (l':l)
 | justification_negi (l5:l) (l':l)
 | justification_ore (l1:l) (l2:l) (l3:l) (l4:l) (l5:l)
 | justification_pbc (l5:l) (l':l).

Inductive prop : Type :=  (*r proposition *)
 | prop_p (p5:p)
 | prop_neg (prop5:prop)
 | prop_and (prop5:prop) (prop':prop)
 | prop_or (prop5:prop) (prop':prop)
 | prop_imp (prop5:prop) (prop':prop)
 | prop_cont : prop.

Inductive reason : Type := 
 | reason_assumption : reason
 | reason_justification (justification5:justification).

Definition proplist : Type := list prop.

Inductive derivation : Type :=  (*r derivation in proof *)
 | derivation_deriv (l5:l) (prop5:prop) (reason5:reason).

Inductive judgment : Type :=  (*r judgment *)
 | judgment_follows (proplist5:proplist) (prop5:prop).

Inductive proof : Type :=  (*r proof *)
 | proof_entries (_:list entry)
with entry : Type :=  (*r proof entry *)
 | entry_derivation (derivation5:derivation)
 | entry_box (proof5:proof)
 | entry_invalid : entry.

Inductive dyadicprop : Type := 
 | dyadicprop_prop (prop5:prop)
 | dyadicprop_dyad (prop5:prop) (prop':prop).

Inductive claim : Type :=  (*r claim *)
 | claim_judgment_proof (judgment5:judgment) (proof5:proof).

Definition G : Type := Map.t dyadicprop.
(** induction principles *)
Section entry_proof_rect.

Variables
  (P_entry : entry -> Prop)
  (P_proof : proof -> Prop)
  (P_list_entry : list entry -> Prop).

Hypothesis
  (H_entry_derivation : forall (derivation5:derivation), P_entry (entry_derivation derivation5))
  (H_entry_box : forall (proof5:proof), P_proof proof5 -> P_entry (entry_box proof5))
  (H_entry_invalid : P_entry entry_invalid)
  (H_proof_entries : forall (entry_list:list entry), P_list_entry entry_list -> P_proof (proof_entries entry_list))
  (H_list_entry_nil : P_list_entry nil)
  (H_list_entry_cons : forall (entry0:entry), P_entry entry0 -> forall (entry_l:list entry), P_list_entry entry_l -> P_list_entry (cons entry0 entry_l)).

Fixpoint proof_ott_ind (n:proof) : P_proof n :=
  match n as x return P_proof x with
  | (proof_entries entry_list) => H_proof_entries entry_list (((fix entry_list_ott_ind (entry_l:list entry) : P_list_entry entry_l := match entry_l as x return P_list_entry x with nil => H_list_entry_nil | cons entry1 xl => H_list_entry_cons entry1(entry_ott_ind entry1)xl (entry_list_ott_ind xl) end)) entry_list)
end
with entry_ott_ind (n:entry) : P_entry n :=
  match n as x return P_entry x with
  | (entry_derivation derivation5) => H_entry_derivation derivation5
  | (entry_box proof5) => H_entry_box proof5 (proof_ott_ind proof5)
  | entry_invalid => H_entry_invalid 
end.

End entry_proof_rect.
Definition proof_list_entry (proof5 : proof) : list entry :=
match proof5 with 
| proof_entries ls => ls
end.

(** definitions *)

(* defns validity *)
Inductive valid_claim : claim -> Prop :=    (* defn valid_claim *)
 | vc_claim : forall (proplist5:proplist) (prop5:prop) (proof5:proof) (l5:l) (justification5:justification),
       (last (proof_list_entry  proof5 ) entry_invalid)   =  (entry_derivation (derivation_deriv l5 prop5 (reason_justification justification5)))  ->
     valid_proof  (Map.empty dyadicprop)  proplist5 proof5 ->
     valid_claim (claim_judgment_proof (judgment_follows proplist5 prop5) proof5)
with valid_proof : G -> proplist -> proof -> Prop :=    (* defn valid_proof *)
 | vp_empty : forall (G5:G) (proplist5:proplist),
     valid_proof G5 proplist5  (proof_entries nil) 
 | vp_derivation : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (justification5:justification) (proof5:proof),
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification justification5)) ->
     valid_proof  (Map.add (dyadic_t l5) (dyadicprop_prop  prop5 )  G5 )  proplist5 proof5 ->
     valid_proof G5 proplist5  (proof_entries (cons  (entry_derivation (derivation_deriv l5 prop5 (reason_justification justification5)))  (proof_list_entry  proof5 ))) 
 | vp_box : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (proof5 proof':proof) (l':l) (prop':prop) (reason5:reason),
       (last (proof_list_entry   (proof_entries (cons  (entry_derivation (derivation_deriv l5 prop5 reason_assumption))  (proof_list_entry  proof5 )))  ) entry_invalid)   =  (entry_derivation (derivation_deriv l' prop' reason5))  ->
     valid_proof  (Map.add (dyadic_t  l5 ) (dyadicprop_prop  prop5 )  G5 )  proplist5 proof5 ->
     valid_proof  (Map.add (dyadic_dyad  l5   l' ) (dyadicprop_dyad  prop5   prop' )  G5 )  proplist5 proof' ->
     valid_proof G5 proplist5  (proof_entries (cons  (entry_box  (proof_entries (cons  (entry_derivation (derivation_deriv l5 prop5 reason_assumption))  (proof_list_entry  proof5 ))) )  (proof_list_entry  proof' ))) 
with valid_derivation : G -> proplist -> derivation -> Prop :=    (* defn valid_derivation *)
 | vd_premise : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop),
      (In  prop5   proplist5 )  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification justification_premise))
 | vd_lem : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop),
     valid_derivation G5 proplist5 (derivation_deriv l5 (prop_or prop5 (prop_neg prop5)) (reason_justification justification_lem))
 | vd_copy : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (l':l),
      (Map.find (dyadic_t  l' )  G5  = Some (dyadicprop_prop  prop5 ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification (justification_copy l')))
 | vd_conte : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (l':l),
      (Map.find (dyadic_t  l' )  G5  = Some (dyadicprop_prop  prop_cont ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification (justification_conte l')))
 | vd_andi : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5 prop':prop) (l1 l2:l),
      (Map.find (dyadic_t  l1 )  G5  = Some (dyadicprop_prop  prop5 ))  ->
      (Map.find (dyadic_t  l2 )  G5  = Some (dyadicprop_prop  prop' ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 (prop_and prop5 prop') (reason_justification (justification_andi l1 l2)))
 | vd_ande1 : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (l':l) (prop':prop),
      (Map.find (dyadic_t  l' )  G5  = Some (dyadicprop_prop  (prop_and prop5 prop') ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification (justification_ande1 l')))
 | vd_ande2 : forall (G5:G) (proplist5:proplist) (l5:l) (prop':prop) (l':l) (prop5:prop),
      (Map.find (dyadic_t  l' )  G5  = Some (dyadicprop_prop  (prop_and prop5 prop') ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop' (reason_justification (justification_ande2 l')))
 | vd_ori1 : forall (G5:G) (proplist5:proplist) (l5:l) (prop5 prop':prop) (l':l),
      (Map.find (dyadic_t  l' )  G5  = Some (dyadicprop_prop  prop5 ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 (prop_or prop5 prop') (reason_justification (justification_ori1 l')))
 | vd_ori2 : forall (G5:G) (proplist5:proplist) (l5:l) (prop5 prop':prop) (l':l),
      (Map.find (dyadic_t  l' )  G5  = Some (dyadicprop_prop  prop' ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 (prop_or prop5 prop') (reason_justification (justification_ori2 l')))
 | vd_impe : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5:prop) (l1 l2:l) (prop':prop),
      (Map.find (dyadic_t  l1 )  G5  = Some (dyadicprop_prop  prop' ))  ->
      (Map.find (dyadic_t  l2 )  G5  = Some (dyadicprop_prop  (prop_imp prop' prop5) ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 prop5 (reason_justification (justification_impe l1 l2)))
 | vd_negnegi : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (l':l),
      (Map.find (dyadic_t  l' )  G5  = Some (dyadicprop_prop  prop5 ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 (prop_neg (prop_neg prop5)) (reason_justification (justification_negnegi l')))
 | vd_negnege : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (l':l),
      (Map.find (dyadic_t  l' )  G5  = Some (dyadicprop_prop  (prop_neg (prop_neg prop5)) ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification (justification_negnege l')))
 | vd_mt : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5:prop) (l1 l2:l) (prop':prop),
      (Map.find (dyadic_t  l1 )  G5  = Some (dyadicprop_prop  (prop_imp prop5 prop') ))  ->
      (Map.find (dyadic_t  l2 )  G5  = Some (dyadicprop_prop  (prop_neg prop') ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 (prop_neg prop5) (reason_justification (justification_mt l1 l2)))
 | vd_nege : forall (G5:G) (proplist5:proplist) (l_5 l1 l2:l) (prop5:prop),
      (Map.find (dyadic_t  l1 )  G5  = Some (dyadicprop_prop  prop5 ))  ->
      (Map.find (dyadic_t  l2 )  G5  = Some (dyadicprop_prop  (prop_neg prop5) ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 prop_cont (reason_justification (justification_nege l1 l2)))
 | vd_impi : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5 prop':prop) (l1 l2:l),
      (Map.find (dyadic_dyad  l1   l2 )  G5  = Some (dyadicprop_dyad  prop5   prop' ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 (prop_imp prop5 prop') (reason_justification (justification_impi l1 l2)))
 | vd_negi : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5:prop) (l1 l2:l),
      (Map.find (dyadic_dyad  l1   l2 )  G5  = Some (dyadicprop_dyad  prop5   prop_cont ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 (prop_neg prop5) (reason_justification (justification_negi l1 l2)))
 | vd_ore : forall (G5:G) (proplist5:proplist) (l_6:l) (prop'':prop) (l1 l2 l3 l4 l5:l) (prop5 prop':prop),
      (Map.find (dyadic_t  l1 )  G5  = Some (dyadicprop_prop  (prop_or prop5 prop') ))  ->
      (Map.find (dyadic_dyad  l2   l3 )  G5  = Some (dyadicprop_dyad  prop5   prop'' ))  ->
      (Map.find (dyadic_dyad  l4   l5 )  G5  = Some (dyadicprop_dyad  prop'   prop'' ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_6 prop'' (reason_justification (justification_ore l1 l2 l3 l4 l5)))
 | vd_pbc : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5:prop) (l1 l2:l),
      (Map.find (dyadic_dyad  l1   l2 )  G5  = Some (dyadicprop_dyad  (prop_neg prop5)   prop_cont ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 prop5 (reason_justification (justification_pbc l1 l2))).
End Fitch.

Module Type PropMappingInterpretation (Import PI : PropInterpretation).
  Parameter mapping : A -> Prop.
End PropMappingInterpretation.

Module FitchMapping 
  (Import PI : PropInterpretation)
  (Import PMI : PropMappingInterpretation PI)
  (ST : SpecType) (SUOT : SpecUsualOrderedType ST)
  (DST : DyadicSpecType ST) (SUOTD : SpecUsualOrderedType DST)
  (Map : FMapInterface.S with Module E := SUOTD).

Module FitchSystem := Fitch PI ST SUOT DST SUOTD Map.
Export FitchSystem.

Definition mprop : Type := Prop.
(** definitions *)

(* defns mapping *)
Inductive prop_mapping : prop -> mprop -> Prop :=    (* defn prop_mapping *)
 | pm_p : forall (p5:p),
     prop_mapping (prop_p p5)  (mapping  p5 ) 
 | pm_neg : forall (prop5:prop) (mprop5:mprop),
     prop_mapping prop5 mprop5 ->
     prop_mapping (prop_neg prop5)  (~  mprop5 ) 
 | pm_and : forall (prop5 prop':prop) (mprop5 mprop':mprop),
     prop_mapping prop5 mprop5 ->
     prop_mapping prop' mprop' ->
     prop_mapping (prop_and prop5 prop')  ( mprop5  /\  mprop' ) 
 | pm_or : forall (prop5 prop':prop) (mprop5 mprop':mprop),
     prop_mapping prop5 mprop5 ->
     prop_mapping prop' mprop' ->
     prop_mapping (prop_or prop5 prop')  ( mprop5  \/  mprop' ) 
 | pm_imp : forall (prop5 prop':prop) (mprop5 mprop':mprop),
     prop_mapping prop5 mprop5 ->
     prop_mapping prop' mprop' ->
     prop_mapping (prop_imp prop5 prop')  ( mprop5  ->  mprop' ) 
 | pm_cont : 
     prop_mapping prop_cont  False .
End FitchMapping.



